[{"content":"\r中国人的性情是总喜欢调和，折中的。譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶，他们就会来调和，愿意开窗了。\n​ ——鲁迅\n\r📝写在前面 由于某些我们不知道的原因，在部分地区的开发者无法正常下载到世界通用的Unity Editor, 通过官方渠道只能下载到地区限定的圈养版。\n然而并不是所有人都好圈养版这口，于是诞生了这样一个repo.为有同样需求的人提供不使用圈养版Unity的选择。\n 本repo收录提供第三方和官方的下载链接，对于第三方链接会明确标注，如需使用第三方链接请注意分辨下载内容的安全性。\n  本站仅为个人性质的原版软件信息收录站点。与Unity官方无关。\n  Unity 替代品推荐 Unity 第三方网盘下载（百度） （内容来源于互联网，如果冒犯请联系删除）(5e4d)  ?\u0026gt; 关于Unity Hub: 暂不收录Unity Hub下载地址，实测发现即使使用原版Unity Hub，在特殊地区的ip的网络中也会“变成”特殊地区的Unity Hub.\n下载链接  Unity 2019 Unity 2018  Unity2019 Unity 2019.4.2 (LTS) 1 Jul, 2020\n 从Unity Hub安装 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases MD5验证信息  Unity-2019.4.2f1.torrent: 45236773C51F287C7804BACBE05B7269 UnityDownloadAssistant-2019.4.2f1.exe: 95A9D158D2451A9B1D7B5A799B7387DF UnityDownloadAssistant-2019.4.2f1.dmg: E109EA2A095FAD7D170DF50759406D26    Unity 2019.4.1 (LTS) 18 June, 2020\n 从Unity Hub安装 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases MD5验证信息  Unity-2019.4.1f1.torrent: 476E06CCDDB3DCC6F71A934D091E1F96 UnityDownloadAssistant-2019.4.1f1.exe: A90C62C31205020372256BA9B564A75B UnityDownloadAssistant-2019.4.1f1.dmg: 0B332D76D225E9A2FED66DF1654F97D7    Unity 2019.4.0 (LTS) 9 June, 2020\n 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效） 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases MD5验证信息  Unity-2019.4.0f1.torrent: E10BA84651073C8681F31B2C359B0492 UnityDownloadAssistant-2019.4.0f1.exe: 705F28507A87487E61A26A6D1733BA12 UnityDownloadAssistant-2019.4.0f1.dmg: 7BF37FC5A0A6E039AFE06A3000E8E81A    Unity 2019.3.15 28 May, 2020\n 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效） 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases MD5验证信息  Unity-2019.3.15f1.torrent: 8588E3F15254717F7DDFB8F61B2C6621 UnityDownloadAssistant-2019.3.15f1.exe: 20FFC868D703E08A74BF64E19C594377 UnityDownloadAssistant-2019.3.15f1.dmg: ED2A64B0356F3F424D1D2D7B09C14956    Unity 2019.3.14 18 May, 2020\n 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效） 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases  Unity 2019.3.13 6 May, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.12 29 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.11 23 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.10 8 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.9 8 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.8 6 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.3.7 26 Mar, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2019.2.21 10 Feb, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity2018 Unity 2018.4.23 (LTS) 19 May, 2020\n 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效） 下载器和Torrent文件请前往Releases地址下载：https://github.com/UnityITellYou/UnityITellYou.github.io/releases  Unity 2018.4.22 (LTS) 24 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 无效，官方未提供该版本torrent文件 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2018.4.21 (LTS) 9 Apr, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效）  Unity 2018.4.20 (LTS) 27 Mar, 2020\n 下载器(Windows) 下载器(OS X) Torrent(Windows+OSX) 从Unity Hub安装 （确保全程不要使用特殊地区ip）（主动代理无效） ","description":"下载到不夹带私货的原版Unity","id":0,"section":"post","tags":["Unity"],"title":"如何下载原版Unity","uri":"https://lx34r.cn/2020/06/19/blog_downloadunityoriginaledition/"},{"content":"\r游戏王基本规则——回合流程，记录一下为以后制作deskBuild游戏提供参考。\r📖写在前面 回合流程是《游戏王OCG》中对战的重要组成部分，它支撑了整场对局的正常进展。每一名玩家在轮到自己的回合时，都会经历六个阶段：“抽卡阶段、准备阶段、主要阶段1、战斗阶段、主要阶段2、结束阶段”。最后的“结束阶段”宣布完成时将回合转交给对方玩家。\n在自己的回合中，通常都只能由自己做决定、发动卡片效果、召唤怪兽或者做其他处理，但如果遇到了“速攻魔法卡”或者是陷阱、特殊效果怪兽一类，也有可能直接打断或终止己方的回合。\n以下只是一般情况，有一些卡的效果会允许特殊情况出现，例如血之代偿允许在对方回合的战斗阶段进行通常召唤、光道魔术师 丽拉召唤上场后可以发效改变表示形式等。\n🃏抽卡阶段 本阶段你从卡组抽出一张卡，然后进入准备阶段。\n本阶段你不能从手中发动除了速攻以外的魔法卡，也不能通常召唤怪兽。\n🧮准备阶段 这一阶段主要是处理一些场上可能存在的强制连锁，以及满足发动条件的魔法陷阱卡效果等。当准备阶段的效果依次触发后，自动进入到“主要阶段1”。\n比如在【削血自闭卡组】中的核心卡熔岩魔神，效果就是每次到此卡控制者的准备阶段都会受到1000点伤害。\n\r🌿主要阶段1 本阶段你按照自己的战术展开，一回合可以在主阶1或主阶2做一次怪兽的通常召唤，当然也能发动魔法、发动陷阱（上回合前覆盖）、覆盖陷阱等。\n虽然一回合只能通招一次，让手中的怪正面攻击或者背面守备上场，但是怪兽的特殊召唤、魔法陷阱的发动与覆盖可是不限制次数的。\n通常召唤、特殊召唤上场的怪兽需要到下一回合才能改变表示形式(攻击/守备)。\n💪战斗阶段 本阶段玩家可以通过“战斗宣言”进行怪兽之间的战斗。需要注意的是，宣布“战斗宣言”在实体卡牌游戏中表示为“用XXX攻击XXX”或者“用XXX对玩家进行直接攻击”的语言。一旦说出后不能反悔，因为有一些卡片的特殊效果就是在进行到“战斗宣言”一瞬间触发的。\n攻击攻击表示怪兽，被击破的一方将承受攻击力差值伤害。守备怪兽被击破不受伤害。1只怪兽1回合只能够攻击1次。\n通常情况下战斗宣言一旦说出后，就会进入到怪兽之间、怪兽直接攻击的战斗阶段。但并不绝对，也有可能发生“攻击卷回”。\n攻击卷回（战斗阶段的卷回） 自己的怪兽攻击宣言后，那个战斗步骤内对方怪兽离场或其他对方怪兽特殊召唤等，对方场上的怪兽数量发生变化时发生「战斗步骤的卷回」。\n卷回发生的场合，该怪兽重新选择是否攻击，选择攻击时重新选择攻击对象。这个时点不是「攻击宣言时」。选择不攻击的场合，也由于进行过攻击宣言，不能在同一战斗阶段再度攻击。\n具体情况：\n  即使因效果处理，导致对方1只怪兽离场之后有1只怪兽特殊召唤，最终没有发生怪兽数量增减的场合，也是怪兽数量发生变化。\neg：被攻击者以家畜虐杀等将怪物收回手札后立即将其特殊召唤。\n  因卡片效果可以直接攻击的怪兽进行直接攻击宣言后，又因其他卡的效果在那个战斗步骤内不能直接攻击的场合也会发生卷回。\neg：持有1个X素材的「No.23 冥界的灵骑士 兰斯洛特」直接攻击宣言后，进入伤害步骤之前若自身③效果有发动，不再持有X素材的场合，①效果不再适用，这个连锁处理完毕时发生卷回。15/11/19\neg：「M·HERO 暗鬼」自身效果适用直接攻击，在战斗步骤内对其发动「禁忌的圣杯」的场合效果无效而发生卷回。若在伤害步骤内才发动的场合，不会发生卷回，照常进行伤害计算，此时因效果无效，战斗伤害不会减半。15/1/8\n  对怪兽攻击后，战斗步骤内不能再攻击该怪兽等的场合也会发生卷回。\neg：「埋伏破坏者」在「技能抽取」的①效果适用中，向表侧表示的怪兽攻击，战斗步骤内「技能抽取」不适用的场合，发生战斗步骤的卷回。17/3/24\neg：「E·HERO 宏伟侠」的②效果特殊召唤的怪兽向怪兽攻击时，对方发动「星级变化」把攻击对象怪兽等级下降到其等级以下的场合，发生战斗步骤的卷回。18/12/24\neg：对方怪兽攻击宣言时，自己发动「旗鼓堂堂」把「磁力指轮」给其他怪兽装备的场合，发生战斗步骤的卷回。即使是持有直接攻击能力的怪兽的直接攻击宣言时也是如此。\neg：持有直接攻击能力的怪兽的直接攻击宣言时，发动「仁王立」的②效果的场合，也发生战斗步骤的卷回。\neg：对方怪兽攻击宣言后，我方以攻击对象以外的怪兽为对象发动「仁王立」的场合，发生卷回，对方必须选择向「仁王立」的效果对象的怪兽攻击，或停止攻击。\neg：向「仁王立」②效果适用的怪兽攻击，战斗步骤内对攻击怪兽发动「禁忌的圣枪」的场合，发生战斗步骤的卷回。\neg：向怪兽攻击的战斗步骤内，对攻击怪兽发动「禁忌的圣枪」，对方连锁对其他怪兽发动「仁王立」②效果的场合，发生战斗步骤的卷回。\n  已经攻击宣言选择了攻击对象，再适用不能作为攻击对象的效果时，由于已经成为攻击对象，不会卷回。\neg：「十二阵·签订」的效果适用中，已经攻击后，卡片效果导致最高攻击力的怪兽发生变化的场合，已经成为攻击对象，不会卷回。17/3/24\neg：「鬼计妖魔·阿鲁卡德」被「技能抽取」无效的状态，已经攻击后「技能抽取」被破坏的场合，已经选择攻击对象的那次攻击不会卷回。17/3/24\n  卡的效果处理或连锁处理途中怪兽数量发生变化的场合，在那些处理全部终了后发生卷回。处理完毕时有诱发类效果或其他快速效果要发动的场合，在那个效果处理结束后发生卷回。\neg：自己的攻击宣言时对方发动「次元幽闭」，并连锁发动「活死人的呼声」的场合，因「活死人的呼声」的效果怪兽在对方场上特殊召唤，但由于是在连锁处理途中，发生卷回之前需要进行「次元幽闭」的处理。就结果来说自己的怪兽被「次元幽闭」除外而不发生卷回。\neg：自己场上存在适用了「仁王立」②效果的「苹果魔术少女」，对方用怪兽攻击这只「苹果魔术少女」，其发动①效果，让「巧克力魔术少女」特殊召唤的场合，由于「仁王立」②效果适用，不能向「巧克力魔术少女」攻击，结果「苹果魔术少女」的①效果处理后，在发生战斗步骤的卷回前，先决定是否发动「激流葬」。\n  攻击者的钻头机人等效果是在伤害判定步骤进行处理，不会发生卷回。\n  收缩、突进等改变了被攻击者的怪物的能力值之类状况不会发生卷回。\n🍂主要阶段2 基本上通主要阶段1可以做的事一样，只是不能再进入战斗阶段而已。\n但是要注意的是如果在阶段1时已经通常召唤、灵摆召唤了怪兽，则无法再次进行此操作。\n🎬结束阶段 一些特定的魔法、陷阱卡会在此阶段触发，与准备阶段相对应。一旦处理完连锁或效果后，将自动结束整个玩家回合，转到对方回合进行新一轮的六个阶段。\n不能发动手中速攻以外的魔法，不能通招怪兽。\n ","description":"游戏王基本规则——回合流程","id":1,"section":"note","tags":["gameDesign","deskBuild","Yu-Gi-Oh!"],"title":"游戏王中的回合流程","uri":"https://lx34r.cn/2020/04/19/gamedesign_yu-gi-ohroundprocess/"},{"content":"\rProjectRoguelike是一款Roguelike风格的2D TopDown游戏。\r📝写在前面 先挖坑，完成了核心战斗再写。\n","description":"记录一下ProjectRoguelike的设计与开发","id":2,"section":"post","tags":["2D","TopDown","Dungeon","Roguelike"],"title":"ProjectRoguelike开发日志","uri":"https://lx34r.cn/2020/04/12/blog_2d_topdown_dungeon_projectroguelike/"},{"content":"\r如果想要网站更好的被搜索引擎收录，就需要进行搜索引擎优化（SEO）。\r☝写在前面 搜索引擎优化简称SEO（Search Engine Optimizing）。\n网站上线后，做SEO时需要检查如下内容：\n 集成Google Analytics或百度统计 为页面增加header信息，如title和description sitemap.xml，大多数网站生成工具都会自动生成站点地图，生成之后将其URL提交的Google Webmaster Tools。 robots.txt，阻止搜索引擎爬取网站上的敏感网页 结构化数据：可以帮助爬虫理解页面内容，参考HTML5的结构化数据  ✌站点内容优化 页面关键词 为每篇博文设置关键词：\n1 2 3 4 5 6 7  --- keywords: - mysite - mysite keyword - Another useful keyword title: My Homepage ---   需要在文章模板的header的\u0026lt;meta\u0026gt;中添加关键词字段。\n1  \u0026lt;meta content=\u0026#34;{{ delimit .Keywords \u0026#34;, \u0026#34; }}\u0026#34; name=\u0026#34;keywords\u0026#34;\u0026gt;   页面标题 同样，每篇文章都要有一个标题，这样方便搜索引擎收录，Hugo 生成的文章一般都会在文章的头部增加该字段，同时文章模板的 header 中也需要有\u0026lt;title\u0026gt;标签。\n1  \u0026lt;title\u0026gt;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026lt;/title\u0026gt;   也可以在meta中添加标题标签。\n1  \u0026lt;meta content=\u0026#34;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026#34; property=\u0026#34;og:title\u0026#34;\u0026gt;   页面描述 在 hugo 的网站配置文件config.toml中设置网站的配置信息，这将显示在浏览器的标签上，该设置是 hugo 内置的。\n1 2  [params] description = \u0026#34;Site stuff for being a good site with internet tubez.\u0026#34;   同时也可以为每篇文章设置描述信息，这个description是十分有用的，当你通过各种社交软件分享页面的时候会解析该字段，同时显示页面的描述信息。\n1 2 3 4 5 6 7 8  --- keywords: - mysite - mysite keyword - Another useful keyword title: My Homepage description: Where you should come to find my homepage updates and stuff ---   同样是在模板的header中的加入标签。\n1  \u0026lt;meta content=\u0026#34;{{ $isHomePage := eq .Title .Site.Title }}{{ .Site.Params.description }}{{ if eq $isHomePage false }} - {{ .Description }}{{ end }}\u0026#34; property=\u0026#34;og:description\u0026#34;\u0026gt;   🕒google搜索优化 打开Google网站站长，点击 “SEARCH CONSOLE” 进入，然后添加资源，如https://lynm3k.coding-pages.com/。会要求下载一个html文件如google48e94c56e986ccb6.html做验证，将这个文件保存到hugo站点根目录下的static目录，更新站点内容让google search console可以访问到进行验证即可。\n进入资源页面，点”索引”下的”站点地图”，在”添加新的站点地图”处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://lynm3k.coding-pages.com/sitemap.xml。\n\r🍀百度搜索优化 打开百度搜索资源平台，点击链接提交，然后点”添加站点”。同样可以用上述文件验证的方式来进行网站验证。\n进入”数据引入”下的”链接提交”，再点 “自动提交” 下的 “sitemap”，在这里可以提交hugo网站的sitemap文件。注意百度不容许以子目录的方式提交子站点，和google不一样，，只能在提交sitemap文件时，提交多个sitemap文件。\n\r🖐️参考资料  Front-End-Checklist Hugo博客百度SEO终极优化,熊掌号自动推送 搜索引擎优化（SEO） ","description":"让搜索引擎更好的收录我们的网站。","id":3,"section":"post","tags":["Hugo","SEO"],"title":"Hugo博客的搜索引擎优化(SEO)","uri":"https://lx34r.cn/2020/04/03/blog_searchengineoptimizing/"},{"content":"\r基于官网的C#发展历史 - C#指南 | Microsoft Docs，通过非常简短的代码将每个新特性演示出来。\rC# 2.0版 - 2005 泛型 Java中的泛型不支持值类型，且会运行时类型擦除，这一点.NET更优秀。\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Declare the generic class. public class GenericList\u0026lt;T\u0026gt; { public void Add(T input) { } } class TestGenericList { private class ExampleClass { } static void Main() { // Declare a list of type int.  GenericList\u0026lt;int\u0026gt; list1 = new GenericList\u0026lt;int\u0026gt;(); list1.Add(1); // Declare a list of type string.  GenericList\u0026lt;string\u0026gt; list2 = new GenericList\u0026lt;string\u0026gt;(); list2.Add(\u0026#34;\u0026#34;); // Declare a list of type ExampleClass.  GenericList\u0026lt;ExampleClass\u0026gt; list3 = new GenericList\u0026lt;ExampleClass\u0026gt;(); list3.Add(new ExampleClass()); } }   分部类型 拆分一个类、一个结构、一个接口或一个方法的定义到两个或更多的文件中是可能的。 每个源文件包含类型或方法定义的一部分，编译应用程序时将把所有部分组合起来。\r1 2 3 4 5 6 7 8 9 10 11 12 13  public partial class Employee { public void DoWork() { } } public partial class Employee { public void GoToLunch() { } }   匿名方法 1 2  Func\u0026lt;int, int, int\u0026gt; sum = delegate (int a, int b) { return a + b; }; Console.WriteLine(sum(3, 4)); // output: 7   可以为null的值类型 1 2 3 4 5 6 7 8 9 10  double? pi = 3.14; char? letter = \u0026#39;a\u0026#39;; int m2 = 10; int? m = m2; bool? flag = null; // An array of a nullable type: int?[] arr = new int?[10];   迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static void Main() { foreach (int number in SomeNumbers()) { Console.Write(number.ToString() + \u0026#34; \u0026#34;); } // Output: 3 5 8  Console.ReadKey(); } public static System.Collections.IEnumerable SomeNumbers() { yield return 3; yield return 5; yield return 8; }   协变和逆变 在 C# 中，协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。 协变保留分配兼容性，逆变则与之相反。\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Assignment compatibility. string str = \u0026#34;test\u0026#34;; // An object of a more derived type is assigned to an object of a less derived type. object obj = str; // Covariance. IEnumerable\u0026lt;string\u0026gt; strings = new List\u0026lt;string\u0026gt;(); // An object that is instantiated with a more derived type argument // is assigned to an object instantiated with a less derived type argument. // Assignment compatibility is preserved. IEnumerable\u0026lt;object\u0026gt; objects = strings; // Contravariance. // Assume that the following method is in the class: // static void SetObject(object o) { } Action\u0026lt;object\u0026gt; actObject = SetObject; // An object that is instantiated with a less derived type argument // is assigned to an object instantiated with a more derived type argument. // Assignment compatibility is reversed. Action\u0026lt;string\u0026gt; actString = actObject;   C# 3.0版 - 2007 自动实现的属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // This class is mutable. Its data can be modified from // outside the class. class Customer { // Auto-implemented properties for trivial get and set  public double TotalPurchases { get; set; } public string Name { get; set; } public int CustomerID { get; set; } // Constructor  public Customer(double purchases, string name, int ID) { TotalPurchases = purchases; Name = name; CustomerID = ID; } // Methods  public string GetContactInfo() { return \u0026#34;ContactInfo\u0026#34;; } public string GetTransactionHistory() { return \u0026#34;History\u0026#34;; } // .. Additional methods, events, etc. } class Program { static void Main() { // Intialize a new object.  Customer cust1 = new Customer(4987.63, \u0026#34;Northwind\u0026#34;, 90108); // Modify a property.  cust1.TotalPurchases += 499.99; } }   匿名类型 1 2 3 4 5  var v = new { Amount = 108, Message = \u0026#34;Hello\u0026#34; }; // Rest the mouse pointer over v.Amount and v.Message in the following // statement to verify that their inferred types are int and n . Console.WriteLine(v.Amount + v.Message);   查询表达式（LINQ） LINQ 的构造可以建立在更细微的视图检查表达式树、Lambda 表达式以及匿名类型的基础上。 不过无论如何 C# 3.0 都提出了革命性的概念。 C# 3.0 开始为 C# 转变为面向对象/函数式混合语言打下基础。\n具体来说，你现在可以编写 SQL 样式的声明性查询对集合以及其他项目执行操作。\n\r1 2 3 4 5 6 7  from p in persons where p.Age \u0026gt; 18 \u0026amp;\u0026amp; p.IsBeatiful select new { p.WeChatId, p.PhoneNumber }   LINQ的意义在于让C#做出了重大调整，本章中说到的lambda表达式、扩展方法、表达式树、匿名类型、自动属性等，都是LINQ的必要组成部分。\n由于用扩展方法的形式也能得到一致的结果，而且还能让代码风格更加一致。\n1 2 3 4 5 6 7 8  // 与上文代码相同，但改成了扩展方法风格： persons .Where(x =\u0026gt; x.Age \u0026gt; 18 \u0026amp;\u0026amp; x.IsBeatiful) .Select(x =\u0026gt; new { x.WeChatId, x.PhoneNumber, });   Lambda表达式 1 2 3 4  Func\u0026lt;int, int\u0026gt; square = x =\u0026gt; x * x; Console.WriteLine(square(5)); // Output: // 25   表达式树 这个是LINQ的基础之一，它的作用是将代码像数据一样，保存在内存中；然后稍后对这些“代码数据”进行重新解释/执行。\nEntity Framework就是一个经典场景，它先将表达式树保存起来，然后执行时，将其翻译为SQL发给数据库执行。\n注意：表达式树并不能表示所有的代码，C# 3.0之后的语法，包含??、?.、async await、可选参数等，都无法放到表达式树中。据说官方准备更新它，但迟迟没有进展。\r 扩展方法 扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  static void Main() { Console.WriteLine (\u0026#34;Perth\u0026#34;.IsCapitalized()); // Equivalent to:  Console.WriteLine (StringHelper.IsCapitalized (\u0026#34;Perth\u0026#34;)); // Interfaces can be extended, too:  Console.WriteLine (\u0026#34;Seattle\u0026#34;.First()); // S } public static class StringHelper { public static bool IsCapitalized (this string s) { if (string.IsNullOrEmpty(s)) return false; return char.IsUpper (s[0]); } public static T First\u0026lt;T\u0026gt; (this IEnumerable\u0026lt;T\u0026gt; sequence) { foreach (T element in sequence) return element; throw new InvalidOperationException (\u0026#34;No elements!\u0026#34;); } }   var 1 2  var i = 10; // Implicitly typed. int i = 10; // Explicitly typed.   分部方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  namespace PM { partial class A { partial void OnSomethingHappened(string s); } // This part can be in a separate file.  partial class A { // Comment out this method and the program  // will still compile.  partial void OnSomethingHappened(String s) { Console.WriteLine(\u0026#34;Something happened: {0}\u0026#34;, s); } } }   对象和集合初始值设定项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Cat { // Auto-implemented properties.  public int Age { get; set; } public string Name { get; set; } public Cat() { } public Cat(string name) { this.Name = name; } }   C# 4.0版 - 2010 dynamic 这个是特性使得CLR不得不进行一次修改。有了这个，C#也能像js、php、python等弱类型语言一样写代码了。\r1 2 3 4 5 6 7  dynamic a = 3; a = 3.14; a = \u0026#34;Hello World\u0026#34;; a = new[] { 1, 2, 3, 4, 5 }; a = new Func\u0026lt;int\u0026gt;(() =\u0026gt; 3); a = new StringBuilder(); Console.WriteLine(a.GetType().Name); // StringBuilder   注意：dynamic可以表示任何东西，包含数组、委托等等。滥用dynamic容易让程序变得很难维护。\r 命名参数/可选参数 1 2 3  PrintOrderDetails(productName: \u0026#34;Red Mug\u0026#34;, sellerName: \u0026#34;Gift Shop\u0026#34;, orderNum: 31); public void ExampleMethod(int required, string optionalstr = \u0026#34;default string\u0026#34;, int optionalint = 10)   泛型中的协变和逆变 1 2 3 4 5  IEnumerable\u0026lt;Derived\u0026gt; d = new List\u0026lt;Derived\u0026gt;(); IEnumerable\u0026lt;Base\u0026gt; b = d; Action\u0026lt;Base\u0026gt; b = (target) =\u0026gt; { Console.WriteLine(target.GetType().Name); }; Action\u0026lt;Derived\u0026gt; d = b; d(new Derived());   类型等效、内置互操作类型 这个主要是为了和COM进行交互。之前需要引用一些COM类型相关的程序集，现在可以直接引用COM。 具体可以参见：https://docs.microsoft.com/zh-cn/dotnet/framework/interop/type-equivalence-and-embedded-interop-types\rC# 5.0版 - 2012 async/await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private DamageResult CalculateDamageDone() { // Code omitted:  //  // Does an expensive calculation and returns  // the result of that calculation. } calculateButton.Clicked += async (o, e) =\u0026gt; { // This line will yield control to the UI while CalculateDamageDone()  // performs its work. The UI thread is free to perform other work.  var damageResult = await Task.Run(() =\u0026gt; CalculateDamageDone()); DisplayDamage(damageResult); };   async/await的本质是状态机，像IEnumerable一样。以前游戏引擎Unity只支持C# 3.0，因此当时它用状态机发Http请求是用的IEnumerable。\nasync/await有两个好处，一是可以避免UI线程卡顿，二是提高系统吞吐率，最终提高性能。\n\r调用方信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public void DoProcessing() { TraceMessage(\u0026#34;Something happened.\u0026#34;); } public void TraceMessage(string message, [CallerMemberName] string memberName = \u0026#34;\u0026#34;, [CallerFilePath] string sourceFilePath = \u0026#34;\u0026#34;, [CallerLineNumber] int sourceLineNumber = 0) { System.Diagnostics.Trace.WriteLine(\u0026#34;message: \u0026#34; + message); System.Diagnostics.Trace.WriteLine(\u0026#34;member name: \u0026#34; + memberName); System.Diagnostics.Trace.WriteLine(\u0026#34;source file path: \u0026#34; + sourceFilePath); System.Diagnostics.Trace.WriteLine(\u0026#34;source line number: \u0026#34; + sourceLineNumber); } // Sample Output: // message: Something happened. // member name: DoProcessing // source file path: c:\\Visual Studio Projects\\CallerInfoCS\\CallerInfoCS\\Form1.cs // source line number: 31   注意这个是编译期生成的，因此比StackTrace更能保证性能。\nC# 6.0版 - 2015 静态导入 终于可以不用写静态类名了。\n1 2 3 4  using static System.Math; using static System.Console; WriteLine(Sin(3.14)); // 0.00159265291648683   异常筛选器 在try-catch时，可以按指定的条件进行catch，其它条件不catch。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static async Task\u0026lt;string\u0026gt; MakeRequest() { WebRequestHandler webRequestHandler = new WebRequestHandler(); webRequestHandler.AllowAutoRedirect = false; using (HttpClient client = new HttpClient(webRequestHandler)) { var stringTask = client.GetStringAsync(\u0026#34;https://docs.microsoft.com/en-us/dotnet/about/\u0026#34;); try { var responseText = await stringTask; return responseText; } catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(\u0026#34;301\u0026#34;)) { return \u0026#34;Site Moved\u0026#34;; } } }   自动初始化表达式 1  public ICollection\u0026lt;double\u0026gt; Grades { get; } = new List\u0026lt;double\u0026gt;();   Expression-bodied 函数成员 1  public override string ToString() =\u0026gt; $\u0026#34;{LastName}, {FirstName}\u0026#34;;   Null传播器 1  var first = person?.FirstName;   字符串内插 1 2  public string GetGradePointPercentage() =\u0026gt; $\u0026#34;Name: {LastName}, {FirstName}. G.P.A: {Grades.Average():F2}\u0026#34;;   nameof表达式 1 2  if (IsNullOrWhiteSpace(lastName)) throw new ArgumentException(message: \u0026#34;Cannot be blank\u0026#34;, paramName: nameof(lastName));   索引初始值设定项 使集合初始化更容易的另一个功能是对 Add 方法使用扩展方法 。 添加此功能的目的是进行 Visual Basic 的奇偶校验。 如果自定义集合类的方法具有通过语义方式添加新项的名称，则此功能非常有用。\rC# 7.0版 - 2017 out变量 1 2 3 4  if (int.TryParse(input, out int result)) Console.WriteLine(result); else Console.WriteLine(\u0026#34;Could not parse input\u0026#34;);   元组和解构 1 2  (string Alpha, string Beta) namedLetters = (\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); Console.WriteLine($\u0026#34;{namedLetters.Alpha}, {namedLetters.Beta}\u0026#34;);   如上代码所示，解构可以将元组拆分为多个变量。\n模式匹配 现在可以在匹配一个类型时，自动转换为这个类型的变量，如果转换失败，这个变量就赋值为默认值（null或0）。\n极简版：\n1 2  if (input is int count) sum += count;   switch/case版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public static int SumPositiveNumbers(IEnumerable\u0026lt;object\u0026gt; sequence) { int sum = 0; foreach (var i in sequence) { switch (i) { case 0: break; case IEnumerable\u0026lt;int\u0026gt; childSequence: { foreach(var item in childSequence) sum += (item \u0026gt; 0) ? item : 0; break; } case int n when n \u0026gt; 0: sum += n; break; case null: throw new NullReferenceException(\u0026#34;Null found in sequence\u0026#34;); default: throw new InvalidOperationException(\u0026#34;Unrecognized type\u0026#34;); } } return sum; }   本地函数 这个主要是方便，javascript就能这样写。\n比lambda的好处在于，这个可以定义在后面，而lambda必须定义在前面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static IEnumerable\u0026lt;char\u0026gt; AlphabetSubset3(char start, char end) { if (start \u0026lt; \u0026#39;a\u0026#39; || start \u0026gt; \u0026#39;z\u0026#39;) throw new ArgumentOutOfRangeException(paramName: nameof(start), message: \u0026#34;start must be a letter\u0026#34;); if (end \u0026lt; \u0026#39;a\u0026#39; || end \u0026gt; \u0026#39;z\u0026#39;) throw new ArgumentOutOfRangeException(paramName: nameof(end), message: \u0026#34;end must be a letter\u0026#34;); if (end \u0026lt;= start) throw new ArgumentException($\u0026#34;{nameof(end)} must be greater than {nameof(start)}\u0026#34;); return alphabetSubsetImplementation(); IEnumerable\u0026lt;char\u0026gt; alphabetSubsetImplementation() { for (var c = start; c \u0026lt; end; c++) yield return c; } }   更多的expression-bodied成员 该功能可以让一些函数写成表达式的形式，非常的方便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Expression-bodied constructor public ExpressionMembersExample(string label) =\u0026gt; this.Label = label; // Expression-bodied finalizer ~ExpressionMembersExample() =\u0026gt; Console.Error.WriteLine(\u0026#34;Finalized!\u0026#34;); private string label; // Expression-bodied get / set accessors. public string Label { get =\u0026gt; label; set =\u0026gt; this.label = value ?? \u0026#34;Default label\u0026#34;; }   Ref 局部变量和返回结果 此功能允许使用并返回对变量的引用的算法，这些变量在其他位置定义。 一个示例是使用大型矩阵并查找具有某些特征的单个位置。 这个功能主要是为了提高值类型的性能，让它真正发挥其作用。C++就有类似的功能。\n1 2 3 4 5 6 7 8 9 10 11 12  public static ref int Find(int[,] matrix, Func\u0026lt;int, bool\u0026gt; predicate) { for (int i = 0; i \u0026lt; matrix.GetLength(0); i++) for (int j = 0; j \u0026lt; matrix.GetLength(1); j++) if (predicate(matrix[i, j])) return ref matrix[i, j]; throw new InvalidOperationException(\u0026#34;Not found\u0026#34;); } ref var item = ref MatrixSearch.Find(matrix, (val) =\u0026gt; val == 42); Console.WriteLine(item); item = 24; Console.WriteLine(matrix[4, 2]);   弃元 通常，在进行元组解构或使用out参数调用方法时，必须定义一个其值无关紧要且你不打算使用的变量。 为处理此情况，C#增添了对弃元的支持 。 弃元是一个名为_的只写变量，可向单个变量赋予要放弃的所有值。 弃元类似于未赋值的变量；不可在代码中使用弃元（赋值语句除外）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  using System; using System.Collections.Generic; public class Example { public static void Main() { var (_, _, _, pop1, _, pop2) = QueryCityDataForYears(\u0026#34;New York City\u0026#34;, 1960, 2010); Console.WriteLine($\u0026#34;Population change, 1960 to 2010: {pop2 - pop1:N0}\u0026#34;); } private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2) { int population1 = 0, population2 = 0; double area = 0; if (name == \u0026#34;New York City\u0026#34;) { area = 468.48; if (year1 == 1960) { population1 = 7781984; } if (year2 == 2010) { population2 = 8175133; } return (name, area, year1, population1, year2, population2); } return (\u0026#34;\u0026#34;, 0, 0, 0, 0, 0); } } // The example displays the following output: // Population change, 1960 to 2010: 393,149   二进制文本和数字分隔符 这个用于使数字和二进制更可读。\n1 2 3 4 5 6 7 8 9 10  // 二进制文本： public const int Sixteen = 0b0001_0000; public const int ThirtyTwo = 0b0010_0000; public const int SixtyFour = 0b0100_0000; public const int OneHundredTwentyEight = 0b1000_0000; // 数字分隔符： public const long BillionsAndBillions = 100_000_000_000; public const double AvogadroConstant = 6.022_140_857_747_474e23; public const decimal GoldenRatio = 1.618_033_988_749_894_848_204_586_834_365_638_117_720_309_179M;   throw表达式 throw之前必须是一个语句，因此有时不得不写更多的代码来完成所需功能。但7.0提供了throw表达式来使代码更简洁，阅读更轻松。\n1 2 3 4 5 6 7 8 9 10 11 12  void Main() { // You can now throw expressions in expressions clauses.  // This is useful in conditional expressions:  string result = new Random().Next(2) == 0 ? \u0026#34;Good\u0026#34; : throw new Exception (\u0026#34;Bad\u0026#34;); result.Dump(); Foo().Dump(); } public string Foo() =\u0026gt; throw new NotImplementedException();   C# 8.0 版 - 2019 Readonly 成员 1 2  public readonly override string ToString() =\u0026gt; $\u0026#34;({X}, {Y}) is {Distance} from the origin\u0026#34;;   默认接口方法 接口中也能定义方法了，这个新功能经常受到争论。但想想，有时是先定义接口，而实现接口需要实现很多相关、但又繁琐的功能，如ASP.NET Core中的ILogger，谁用谁知道，特别多需要实现的方法，但又都差不多。因此所以这个功能其实很有必要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void Main() { ILogger foo = new Logger(); foo.Log (new Exception (\u0026#34;test\u0026#34;)); } class Logger : ILogger { public void Log (string message) =\u0026gt; Console.WriteLine (message); } interface ILogger { void Log (string message); // Adding a new member to an interface need not break implementors:  public void Log (Exception ex) =\u0026gt; Log (ExceptionHeader + ex.Message); // The static modifier (and other modifiers) are now allowed:  static string ExceptionHeader = \u0026#34;Exception: \u0026#34;; }   模式匹配增强 这个是为简化代码、函数式编程而生的，我个人非常喜欢。\n属性模式 1 2 3 4 5 6 7 8 9  public static decimal ComputeSalesTax(Address location, decimal salePrice) =\u0026gt; location switch { { State: \u0026#34;WA\u0026#34; } =\u0026gt; salePrice * 0.06M, { State: \u0026#34;MN\u0026#34; } =\u0026gt; salePrice * 0.75M, { State: \u0026#34;MI\u0026#34; } =\u0026gt; salePrice * 0.05M, // other cases removed for brevity...  _ =\u0026gt; 0M };   Tuple模式 1 2 3 4 5 6 7 8 9 10 11  public static string RockPaperScissors(string first, string second) =\u0026gt; (first, second) switch { (\u0026#34;rock\u0026#34;, \u0026#34;paper\u0026#34;) =\u0026gt; \u0026#34;rock is covered by paper. Paper wins.\u0026#34;, (\u0026#34;rock\u0026#34;, \u0026#34;scissors\u0026#34;) =\u0026gt; \u0026#34;rock breaks scissors. Rock wins.\u0026#34;, (\u0026#34;paper\u0026#34;, \u0026#34;rock\u0026#34;) =\u0026gt; \u0026#34;paper covers rock. Paper wins.\u0026#34;, (\u0026#34;paper\u0026#34;, \u0026#34;scissors\u0026#34;) =\u0026gt; \u0026#34;paper is cut by scissors. Scissors wins.\u0026#34;, (\u0026#34;scissors\u0026#34;, \u0026#34;rock\u0026#34;) =\u0026gt; \u0026#34;scissors is broken by rock. Rock wins.\u0026#34;, (\u0026#34;scissors\u0026#34;, \u0026#34;paper\u0026#34;) =\u0026gt; \u0026#34;scissors cuts paper. Scissors wins.\u0026#34;, (_, _) =\u0026gt; \u0026#34;tie\u0026#34; };   位置模式 1 2 3 4 5 6 7 8 9 10  static Quadrant GetQuadrant(Point point) =\u0026gt; point switch { (0, 0) =\u0026gt; Quadrant.Origin, var (x, y) when x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 =\u0026gt; Quadrant.One, var (x, y) when x \u0026lt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 =\u0026gt; Quadrant.Two, var (x, y) when x \u0026lt; 0 \u0026amp;\u0026amp; y \u0026lt; 0 =\u0026gt; Quadrant.Three, var (x, y) when x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt; 0 =\u0026gt; Quadrant.Four, var (_, _) =\u0026gt; Quadrant.OnBorder, _ =\u0026gt; Quadrant.Unknown };   switch表达式 这个功能能使代码从大量的if/else或switch/case变成“一行代码”，符合函数式编程的思想，非常好用！\n1 2 3 4 5 6 7 8 9 10 11 12  public static RGBColor FromRainbow(Rainbow colorBand) =\u0026gt; colorBand switch { Rainbow.Red =\u0026gt; new RGBColor(0xFF, 0x00, 0x00), Rainbow.Orange =\u0026gt; new RGBColor(0xFF, 0x7F, 0x00), Rainbow.Yellow =\u0026gt; new RGBColor(0xFF, 0xFF, 0x00), Rainbow.Green =\u0026gt; new RGBColor(0x00, 0xFF, 0x00), Rainbow.Blue =\u0026gt; new RGBColor(0x00, 0x00, 0xFF), Rainbow.Indigo =\u0026gt; new RGBColor(0x4B, 0x00, 0x82), Rainbow.Violet =\u0026gt; new RGBColor(0x94, 0x00, 0xD3), _ =\u0026gt; throw new ArgumentException(message: \u0026#34;invalid enum value\u0026#34;, paramName: nameof(colorBand)), };   using声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  static int WriteLinesToFile(IEnumerable\u0026lt;string\u0026gt; lines) { using var file = new System.IO.StreamWriter(\u0026#34;WriteLines2.txt\u0026#34;); // Notice how we declare skippedLines after the using statement.  int skippedLines = 0; foreach (string line in lines) { if (!line.Contains(\u0026#34;Second\u0026#34;)) { file.WriteLine(line); } else { skippedLines++; } } // Notice how skippedLines is in scope here.  return skippedLines; // file is disposed here }   静态本地函数 相比非静态本地函数，静态本地函数没有闭包，因此生成的代码更少，性能也更容易控制。\n1 2 3 4 5 6 7 8  int M() { int y = 5; int x = 7; return Add(x, y); static int Add(int left, int right) =\u0026gt; left + right; }   异步流 这个功能和IEnumerable、Task对应，一个经典的表格如下：\n    单值 多值     同步 T IEnumerable   异步 Task ?    其中，这个问号?终于有了答案，它就叫异步流——IAsyncEnumerable：\n1 2 3 4 5 6 7 8  public static async System.Collections.Generic.IAsyncEnumerable\u0026lt;int\u0026gt; GenerateSequence() { for (int i = 0; i \u0026lt; 20; i++) { await Task.Delay(100); yield return i; } }   不像IEnumerable，IAsyncEnumerable系统还没有内置扩展方法，因此可能没有IEnumerable方便，但是可以通过安装NuGet包f来实现和IEnumerable一样（或者更爽）的效果。\n索引和范围 和Python中的切片器一样，只是-用^代替了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  var words = new string[] { // index from start index from end  \u0026#34;The\u0026#34;, // 0 ^9  \u0026#34;quick\u0026#34;, // 1 ^8  \u0026#34;brown\u0026#34;, // 2 ^7  \u0026#34;fox\u0026#34;, // 3 ^6  \u0026#34;jumped\u0026#34;, // 4 ^5  \u0026#34;over\u0026#34;, // 5 ^4  \u0026#34;the\u0026#34;, // 6 ^3  \u0026#34;lazy\u0026#34;, // 7 ^2  \u0026#34;dog\u0026#34; // 8 ^1 }; // 9 (or words.Length) ^0  var quickBrownFox = words[1..4]; var lazyDog = words[^2..^0]; var allWords = words[..]; // contains \u0026#34;The\u0026#34; through \u0026#34;dog\u0026#34;. var firstPhrase = words[..4]; // contains \u0026#34;The\u0026#34; through \u0026#34;fox\u0026#34; var lastPhrase = words[6..]; // contains \u0026#34;the\u0026#34;, \u0026#34;lazy\u0026#34; and \u0026#34;dog\u0026#34;   Null合并赋值 1 2 3 4 5 6 7 8 9  List\u0026lt;int\u0026gt; numbers = null; int? i = null; numbers ??= new List\u0026lt;int\u0026gt;(); numbers.Add(i ??= 17); numbers.Add(i ??= 20); Console.WriteLine(string.Join(\u0026#34; \u0026#34;, numbers)); // output: 17 17 Console.WriteLine(i); // output: 17   非托管构造类型 与任何非托管类型一样，可以创建指向此类型的变量的指针，或针对此类型的实例在堆栈上分配内存块。\n1 2 3 4 5 6  Span\u0026lt;Coords\u0026lt;int\u0026gt;\u0026gt; coordinates = stackalloc[] { new Coords\u0026lt;int\u0026gt; { X = 0, Y = 0 }, new Coords\u0026lt;int\u0026gt; { X = 0, Y = 3 }, new Coords\u0026lt;int\u0026gt; { X = 4, Y = 0 } };   嵌套表达式中的 stackalloc 1 2 3  Span\u0026lt;int\u0026gt; numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 }; var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6 ,8 }); Console.WriteLine(ind); // output: 1   ","description":"基于官网的C#发展历史，通过非常简短的代码将每个新特性演示出来。","id":4,"section":"note","tags":["JavaScript","regexp"],"title":"C# 各版本新功能列表","uri":"https://lx34r.cn/2020/02/21/new-features-in-c_sharp/"},{"content":"\r使用docx+regex从Word获取特定内容\r🤳开始之前 \r💃调整姿势 读取word 这里我使用Python-docx模块来操作word。\n使用pip安装\r使用easy_install安装\r\r1  pip install python-docx   \r\r1  easy_install python-docx   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"aa481ddaf8ab76ce\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Python-docx简单示例\n1 2 3 4 5 6 7 8 9 10 11 12  from docx import Document from docx.shared import Inches document = Document(\u0026#39;demo.docx\u0026#39;) #打开文件demo.docx for paragraph in document.paragraphs: print(paragraph.text) #打印各段落内容文本 document.add_paragraph( \u0026#39;Add new paragraph\u0026#39;, style=\u0026#39;ListNumber\u0026#39; ) #添加新段落 document.save(\u0026#39;demo.docx\u0026#39;) #保存文档   获取特定文本 通过跟学妹沟通，拿到几份判决书看了下，需要的文本就是绿框部分。前后有明显的起始截止标识，直接正则表达式。\n\r\r正则表达式\r\r判决如下：(.*?)如不服本判决，\n  .匹配任意除换行符\\n外的字符；\n  *表示匹配前一个字符0次或无限次；\n  +或后跟?表示非贪婪匹配，即尽可能少的匹配，如?重复任意次，但尽可能少重复；\n  .*? 表示匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n如：a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab和ab。\n  \r \r输出特定文本 使用Python-docx模块的add_paragraph()方法将文本从list输出至word中。\n👨‍💻具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #!/usr/bin/env python3 # -*- coding: utf-8 -*- import re import os import importlib,sys # Python 3.4 之后弃用imp importlib.reload(sys) # 处理windows与其他os的路径中的\\/ from pathlib import Path from docx import Document data_files=[(\u0026#34;\u0026#34;,[\u0026#34;MSVCR100.dll\u0026#34;])] file_path = Path(sys.path[0]) # 调试使用脚本路径 #file_path = Path(os.getcwd()) # 打包使用程序路径 document = Document() from docx.oxml.ns import qn document.styles[\u0026#39;Normal\u0026#39;].font.name = u\u0026#39;宋体\u0026#39; document.styles[\u0026#39;Normal\u0026#39;]._element.rPr.rFonts.set(qn(\u0026#39;w:eastAsia\u0026#39;), u\u0026#39;宋体\u0026#39;) def searchFiles(): word_dir = os.listdir(file_path / \u0026#34;word\u0026#34;) # 文件放置在当前目录下的word文件夹中 i = 0 for s in word_dir: wordName = word_dir[i] i = i + 1 str1 = file_path / \u0026#34;word\u0026#34; / wordName docxSearch(str1) document.save(file_path / \u0026#34;这个就是你需要的文档啦.docx\u0026#34;) def docxSearch(wordName): template = \u0026#39;\u0026#39; file = Document(wordName) for para in file.paragraphs: template = template + para.text # print( para.text ) slotList = RegularEx(template) for slot in slotList: print (slot) document.add_paragraph(slot,style=\u0026#39;List Number\u0026#39;) def RegularEx(temp): rule = r\u0026#39;判决如下：(.*?)如不服本判决，\u0026#39; slotList = re.findall(rule, temp) return slotList if __name__ == \u0026#39;__main__\u0026#39;: searchFiles()   ","description":"使用docx+regex从Word获取特定内容","id":5,"section":"post","tags":["python","word","regexp"],"title":"获取Word特定内容","uri":"https://lx34r.cn/2019/12/08/tool_gettextfromword/"},{"content":"\r有时候需要使用正则表达式去验证一些输入信息，故对这些正则表达式进行记录，以便日后查询。\r📧电子邮件 1 2  var email = \u0026#39;zyssmart@live.com\u0026#39;; var emailRegexp = /^[^\\s@]+@[^\\s@.]+\\.[^\\s@.]+$/;   🔑密码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var checkPass = function (password) { var theLength = /^.{8,32}$/; // 长度在8~32个字符之间  var upper = /[A-Z]/; // 大写字母  var lower = /[a-z]/; // 小写字母  var numbers = /[0-9]/; // 数字  var special = /[!\u0026#34;#$%\u0026amp;\u0026#39;()*+,\\-./:;\u0026lt;=\u0026gt;?@[\\\\\\]^_`{|}~]/; // 特殊字符  if (theLength.test(password) \u0026amp;\u0026amp; upper.test(password) \u0026amp;\u0026amp; lower.test(password) \u0026amp;\u0026amp; numbers.test(password) \u0026amp;\u0026amp; special.test(password) ) { return true; } else { return false; } }   📅日期 1 2  var date = \u0026#39;2019/01/01\u0026#39;; var dateRegexp = /^([0-9]{2})?[0-9]{2}/(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])$/;   📇身份证号 1  var IDRegexp=/\\d{17}[\\d|x]|\\d{15}/;   🇨🇳中文 1  var chineseRegexp = /[\\u4e00-\\u9fa5]/gm   🔣特殊字符 1 2 3 4  //英文特殊字符 var regEn = /[`~!@#$%^\u0026amp;*()_+\u0026lt;\u0026gt;?:\u0026#34;{},\\\\.\\/;\u0026#39;[\\]]/im //中文特殊字符 var regCn = /[·！#￥（——）：；“”‘、，|《。》？、【】[\\]]/im   📱手机号码 1  var phoneNumRegexp = /^[1][3,4,5,7,8][0-9]{9}$/   🚘车牌号 1 2 3 4  //新能源 长度为8 var xreg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/ //常规车牌 长度为7 var creg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/   ","description":"邮件、密码、日期等的合法性校验","id":6,"section":"note","tags":["JavaScript","regexp"],"title":"JavaScript常用的正则表达式","uri":"https://lx34r.cn/2019/01/08/regexp_javascriptregexp/"},{"content":"\rCSV 文件（Comma Separated Values file，即逗号分隔值文件）是一种纯文本文件，它使用特定的结构来排列表格数据。\r📝写在前面 csv特点\n 纯文本，使用某个字符集，比如ASCII、Unicode、EBCDIC或GB2312； 由记录组成（典型的是每行一条记录）； 每条记录被分隔符分隔为字段，常用分隔符：逗号（,）、制表符（\\t）、冒号（:)和分号（;）有时分隔符可以包括可选的空格； 每行末尾是CR回车符和LF换行符（请注意，Linux系统以LF结尾，MacOS系统以CR结尾）。 每条记录都有同样的字段序列。  一般为每行开头不空格，第一行是属性列，数据列之间以间隔符为间隔无空格，行之间无空行。\n如果有空行或者数据集中行末有空格，读取数据时一般会出错，引发[list index out of range]错误。\n🌊使用csv库读写csv文件 reader对象可以通过指定附加参数，处理不同风格的 CSV 文件，其中一些如下所示：\n delimiter指定用于分隔每个字段的字符，默认值为逗号（,）。 quotechar指定用于包围包含分隔符字符的字段的字符，默认值为双引号（\u0026quot;）。 escapechar指定用于转义分隔符的字符，以防引号未使用。默认值为无转义字符。  读取csv文件并直接输出 如果csv文件不是很复杂则可以直接输出文件中每行的数据\n1 2 3 4 5 6 7 8  import csv def read_csv_file(path): with open(path, \u0026#39;rb\u0026#39;) as f: # r表示读取，b表示读取的文件 reader = csv.reader(f) for row in reader: print row f.close()   将csv文件并输出为字典 如果想要获取某列的数据，在上面的代码中用数组指定索引即可得到，但是如果较复杂的话采用下面的形式更好，输出字典。这样还有个好处是有时需要反复读取csv文件，但是第一次读取后文件对象已经指向文件末尾了，所以需要将数据存入普通数组，方便后面处理：\n1 2 3 4 5 6 7 8 9 10 11 12  import csv def read_csv_data(path): data_lines = [] with open(path, \u0026#39;rb\u0026#39;) as f: reader = csv.reader(f) fields = reader.next() # 过滤掉表头(如果有的话) for row in reader: items = dict(zip(fields, row)) data_lines.append(items) f.close() return data_lines   写入csv文件 1 2 3 4 5 6 7 8 9 10 11 12  import csv def write_csv_file(path) with open(path, \u0026#39;wb\u0026#39;) as f: # w表示写入，b表示写入文件 writer = csv.writer(f) writer.writerow([\u0026#39;name\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;age\u0026#39;]) # writerow是写入一行数据 data = [ ( \u0026#39;ych \u0026#39;,\u0026#39;china\u0026#39;,\u0026#39;25\u0026#39;), ( \u0026#39;Lily\u0026#39;, \u0026#39;USA\u0026#39;, \u0026#39;24\u0026#39;)] writer.writerows(data) # writerows是写入多行数据 f.close()   🌊输出某列的匹配/不匹配的记录 主要用于从csv文件中抽取出匹配特定列的特定字段集合的记录，比如现有这么一个csv文件（表格化后）\n   Name Age sex     Bob 27 male   Alice 23 female   Lancelot 23 unknown   \u0026hellip; \u0026hellip; \u0026hellip;    需要输出其中age为23的记录到新的csv文件，则我们可以先把23这么个关键词用一个列表收集起来，然后通过下列代码从csv文件中找出所有符合条件的记录并输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import sys import csv # try to fix \u0026#39;_csv.Error: field larger than field limit (131072)\u0026#39; csv.field_size_limit(sys.maxint) # write to common csv file with delimiter \u0026#39;,\u0026#39; # output the rows with matched id in id_list to a new csv file def csv_match(id_list,key,input_file,output_file): with open(input_file, \u0026#39;rb\u0026#39;) as f: reader = csv.DictReader(f) rows = [row for row in reader if row[key] in set(id_list)] header = rows[0].keys() with open(output_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;,\u0026#39;.join(header)) f.write(\u0026#39;\\n\u0026#39;) for data in rows: f.write(\u0026#34;,\u0026#34;.join(data[h] for h in header)) f.write(\u0026#39;\\n\u0026#39;)   调用的时候：\n1 2  lst=[\u0026#39;23\u0026#39;] csv_match(lst,\u0026#39;age\u0026#39;,\u0026#39;in.csv\u0026#39;,\u0026#39;out.csv\u0026#39;)   key为需要匹配的列名，另外我们也可以提取不符合该条件的记录，‘取个反’就行了\n1 2 3 4 5 6 7 8 9 10 11 12 13  # output the rows with not matched id in id_list to a new csv file def csv_not_match(id_list, key, input_file, output_file): with open(input_file, \u0026#39;rb\u0026#39;) as f: reader = csv.DictReader(f) rows = [row for row in reader if not row[key] in set(id_list)] header = rows[0].keys() with open(output_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;,\u0026#39;.join(header)) f.write(\u0026#39;\\n\u0026#39;) for data in rows: f.write(\u0026#34;,\u0026#34;.join(data[h] for h in header)) f.write(\u0026#39;\\n\u0026#39;)   对于需要判断csv文件中多个列的值的情况，只需修改对应的判别条件和传入参数情况即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # output the rows with matched key1 or key2 in refer_list to a new csv file # @params # refer_list: the list referred to # key,key2: column name of csv file to check the value in the refer_list or not def csv_match2(refer_list, key1, key2, input_file, output_file): with open(input_file, \u0026#39;rb\u0026#39;) as f: reader = csv.DictReader(f) rows = [row for row in reader if (row[key1] in set(refer_list)) or (row[key2] in set(refer_list))] header = rows[0].keys() with open(output_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;,\u0026#39;.join(header)) f.write(\u0026#39;\\n\u0026#39;) for data in rows: f.write(\u0026#34;,\u0026#34;.join(data[h] for h in header)) f.write(\u0026#39;\\n\u0026#39;)   🌊调整列的顺序 有时候我们输出的或者拿到的csv文件的列的顺序不够‘人性化’，为了让我们看起来更加直观，更舒服一点，我们可以按照我们的需要调整列的顺序\n1 2 3 4 5 6 7 8 9  import csv # reorder the column of the csv file to what you want def csv_reorder(in_file, out_file,lst_order): with open(in_file, \u0026#39;rb\u0026#39;) as infile, open(out_file, \u0026#39;wb\u0026#39;) as outfile: fieldnames=lst_order writer = csv.DictWriter(outfile, fieldnames=fieldnames) writer.writeheader() for row in csv.DictReader(infile): writer.writerow(row)   其中lst_order为我们需要的列名顺序，用list存储，举个例子\nseason_id,league_name,league_size\r2003,scottish-premiership,12\r2016,1-hnl,10\r2004,alka-superligaen,12\r2006,allsvenskan,14\r1992,premier-league,22\r...\r现在我们想调整他的顺序，按照league_name,season_id,league_size的顺序重新组合一下\n则调用\n1 2  lst_order = [\u0026#39;league_name\u0026#39;,\u0026#39;season_id\u0026#39;,\u0026#39;league_size\u0026#39;] csv_reorder(\u0026#39;leagues_size.csv\u0026#39;, \u0026#39;leagues_size_new.csv\u0026#39;, lst_order)   得到结果\nleague_name,season_id,league_size\rscottish-premiership,2003,12\r1-hnl,2016,10\ralka-superligaen,2004,12\rallsvenskan,2006,14\rpremier-league,1992,22\r...\r🌊抽取特定列 抽取特定列的所有值并存储于列表 获取某列原始的数据并保存为列表\n1 2 3 4 5 6 7 8 9 10  # get certain column value of csv(for common csv file(\u0026#39;,\u0026#39;)) def get_origin_column_value(file, column_name): with open(file, \u0026#39;rb\u0026#39;) as f: role_list = [] reader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;) fieldnames = next(reader) reader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;) for row in reader: role_list.append(row[column_name]) return role_list   对于某些有特殊需要的可以直接修改代码，比如对原始的列的值进行除重和排序后获取，如下\n1 2 3 4 5 6 7 8 9 10 11  # get certain column value of csv(for common csv file(\u0026#39;,\u0026#39;)),and judge if it\u0026#39;s repeated def get_column_value2(file, column_name): with open(file, \u0026#39;rb\u0026#39;) as f: role_list = [] reader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;) fieldnames = next(reader) reader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;) for row in reader: role_list.append(row[column_name]) role_set = set(role_list) return sorted(list(role_set))   根据下标抽取特定列到某个新的csv文件 1 2 3 4 5 6 7 8  import csv # extract certain column from csv file according to the column# def column_extract(file_in,file_out,index): with open(file_in,\u0026#39;r\u0026#39;) as f_in: with open(file_out,\u0026#39;w\u0026#39;) as f_out: for line in f_in: f_out.write(line.split(\u0026#39;,\u0026#39;)[index]) f_out.write(\u0026#39;\\n\u0026#39;) # comment if a new line already exists   🌊除去完全重复的记录 1 2 3 4 5 6 7 8 9 10  # eliminated the completely repeated record in repeated file for further analysis def eliminate_repeated_row(in_file,out_file): with open(in_file,\u0026#39;rb\u0026#39;) as in_file,open(out_file,\u0026#39;wb\u0026#39;)as out_file: seen=set() for line in in_file: # print line if line in seen:continue seen.add(line) out_file.write(line)   🌊对csv文件按照某一列排序 1 2 3 4 5 6 7 8 9  # sort the csv file by certain column to put the similar record together for further analysis def sort_csv_byColumn(in_file, out_file,column_name): with open(in_file, \u0026#39;rb\u0026#39;) as f: reader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;) fieldnames = next(reader) reader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;) sorted_list = sorted(reader, key=lambda row: row[column_name], reverse=True) # print sorted_list csv_converter.nestedlist2csv(sorted_list, out_file)   例如我们按照league_name排序(注意这里调用了csv转换器中的方法将列表的字典转换为csv文件)\n1  sort_csv_byColumn(\u0026#39;leagues_size.csv\u0026#39;,\u0026#39;ordered_leagues_size.csv\u0026#39;,\u0026#39;league_name\u0026#39;)   得到结果\nseason_id,league_name,league_size\r2008,virsliga,9\r2010,virsliga,9\r2012,a-lyga,9\r2012,a-pojat-sm-sarja,9\r2013,a-pojat-sm-sarja,9\r1953,salzburger-liga,9\r2010,3-lig-grup-1,9\r2013,armenian-first-league,9\r2016,ykkonen,9\r2014,stirling-sports-premiership,9\r2014,hong-kong-premier-league,9\r2015,hong-kong-premier-league,9\r1996,s-league,9\r2015,s-league,9\r2013,united-football-league,9\r2016,i-league,9\r🌊键值互换 csv文件每一条记录其实可以看作是一个字典，有时csv文件里有不同的键对应同一个值的情况，我们想讲记录反转一下，即让值作为键，对应的键作为值\n1 2 3 4 5 6  # return a dict with the same value in original as new key and keys as value def dict_same_value(original_dict): new_dict={} for k,v in original_dict.iteritems(): new_dict.setdefault(v,[]).append(k) return new_dict   🌊参考资料 CSV_Toolkit\n","description":"python处理csv文件经常用到的方法","id":7,"section":"post","tags":["python","csv"],"title":"python处理csv文件","uri":"https://lx34r.cn/2018/08/20/blog_pythonoperatecsv/"},{"content":"\r\rKnow yourself and be yourself!\r\r 纽约时间比加州时间早三个小时，\nNew York is 3 hours ahead of California,\n但加州时间并没有变慢。\nbut it does not make California slow.\n有人22岁就毕业了，\nSomeone graduated at the age of 22,\n但等了5年才找到好的工作！\nbut waited 5 years before securing a good job!\n有人25岁就当上CEO，\nSomeone became a CEO at 25,\n却在50岁去世。\nand died at 50.\n也有人迟到50岁才当上CEO，\nWhile another became a CEO at 50,\n然后活到90岁。\nand lived to 90 years.\n有人依然单身，\nSomeone is still single,\n同时也有人已婚。\nwhile someone else got married.\n奥巴马55岁就退休，\nObama retires at 55,\n川普70岁才开始当总统。\nbut Trump starts at 70.\n世上每个人本来就有自己的发展时区。\nAbsolutely everyone in this world works based on their Time Zone.\n身边有些人看似走在你前面，\nPeople around you might seem to go ahead of you,\n也有人看似走在你后面。\nsome might seem to be behind you.\n但其实每个人在自己的时区有自己的步程。\nBut everyone is running their own RACE, in their own TIME.\n不用嫉妒或嘲笑他们。\nDon’t envy them or mock them.\n他们都在自己的时区里，你也是！\nThey are in their TIME ZONE, and you are in yours!\n生命就是等待正确的行动时机。\nLife is about waiting for the right moment to act.\n所以，放轻松。\nSo, RELAX.\n你没有落后。\nYou’re not LATE.\n你没有领先。\nYou’re not EARLY.\n在命运为你安排的属于自己的时区里，一切都准时。\nYou are very much ON TIME, and in your TIME ZONE Destiny set up for you.\n \r Expectations 二十而立\n三十不惑\n四十知天命\n五十耳顺\n六十从心所欲\nBlog Timeline  2020.04.01：将博客迁移至Hugo+Zzo theme。 2018.05.10：使用Hexo+NEXT theme搭建个人博客。  ","description":"你曾经也是第一名啊。","id":8,"section":"","tags":null,"title":"About","uri":"https://lx34r.cn/about/"}]