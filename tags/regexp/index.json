[{"content":"\r如果想要网站更好的被搜索引擎收录，就需要进行搜索引擎优化（SEO）。\r☝写在前面 搜索引擎优化简称SEO（Search Engine Optimizing）。\n网站上线后，做SEO时需要检查如下内容：\n 集成Google Analytics或百度统计 为页面增加header信息，如title和description sitemap.xml，大多数网站生成工具都会自动生成站点地图，生成之后将其URL提交的Google Webmaster Tools。 robots.txt，阻止搜索引擎爬取网站上的敏感网页 结构化数据：可以帮助爬虫理解页面内容，参考HTML5的结构化数据  ✌站点内容优化 页面关键词 为每篇博文设置关键词：\n---\rkeywords:\r- mysite\r- mysite keyword\r- Another useful keyword\rtitle: My Homepage\r---\r需要在文章模板的header的\u0026lt;meta\u0026gt;中添加关键词字段。\n\u0026lt;meta content=\u0026quot;{{ delimit .Keywords \u0026quot;, \u0026quot; }}\u0026quot; name=\u0026quot;keywords\u0026quot;\u0026gt;\r页面标题 同样，每篇文章都要有一个标题，这样方便搜索引擎收录，Hugo 生成的文章一般都会在文章的头部增加该字段，同时文章模板的 header 中也需要有\u0026lt;title\u0026gt;标签。\n1  \u0026lt;title\u0026gt;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026lt;/title\u0026gt;\r  也可以在meta中添加标题标签。\n1  \u0026lt;meta content=\u0026#34;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026#34; property=\u0026#34;og:title\u0026#34;\u0026gt;\r  页面描述 在 hugo 的网站配置文件config.toml中设置网站的配置信息，这将显示在浏览器的标签上，该设置是 hugo 内置的。\n[params]\rdescription = \u0026quot;Site stuff for being a good site with internet tubez.\u0026quot;\r同时也可以为每篇文章设置描述信息，这个description是十分有用的，当你通过各种社交软件分享页面的时候会解析该字段，同时显示页面的描述信息。\n---\rkeywords:\r- mysite\r- mysite keyword\r- Another useful keyword\rtitle: My Homepage\rdescription: Where you should come to find my homepage updates and stuff\r---\r同样是在模板的header中的加入标签。\n1  \u0026lt;meta content=\u0026#34;{{ $isHomePage := eq .Title .Site.Title }}{{ .Site.Params.description }}{{ if eq $isHomePage false }} - {{ .Description }}{{ end }}\u0026#34; property=\u0026#34;og:description\u0026#34;\u0026gt;\r  🕒google搜索优化 打开Google网站站长，点击 “SEARCH CONSOLE” 进入，然后添加资源，如https://lynm3k.coding-pages.com/。会要求下载一个html文件如google48e94c56e986ccb6.html做验证，将这个文件保存到hugo站点根目录下的static目录，更新站点内容让google search console可以访问到进行验证即可。\n进入资源页面，点”索引”下的”站点地图”，在”添加新的站点地图”处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://lynm3k.coding-pages.com/sitemap.xml。\n\r🍀百度搜索优化 打开百度搜索资源平台，点击链接提交，然后点”添加站点”。同样可以用上述文件验证的方式来进行网站验证。\n进入”数据引入”下的”链接提交”，再点 “自动提交” 下的 “sitemap”，在这里可以提交hugo网站的sitemap文件。注意百度不容许以子目录的方式提交子站点，和google不一样，，只能在提交sitemap文件时，提交多个sitemap文件。\n\r🖐️参考资料  Front-End-Checklist Hugo博客百度SEO终极优化,熊掌号自动推送 搜索引擎优化（SEO） ","description":"让搜索引擎更好的收录我们的网站。","id":0,"section":"posts","tags":["Hugo","SEO"],"title":"Hugo博客的搜索引擎优化(SEO)","uri":"https://lynm3k.coding-pages.com/posts/blog-searchengineoptimizing/"},{"content":"\r使用docx+regex从Word获取特定内容\r🤳开始之前 \r💃调整姿势 读取word 这里我使用Python-docx模块来操作word。\n使用pip安装\r使用easy_install安装\r\r1  pip install python-docx\r  \r\r1  easy_install python-docx\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"5f3c848fa68df499\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Python-docx简单示例\n1 2 3 4 5 6 7 8 9 10 11 12  from docx import Document\rfrom docx.shared import Inches\rdocument = Document(\u0026#39;demo.docx\u0026#39;) #打开文件demo.docx\r for paragraph in document.paragraphs:\rprint(paragraph.text) #打印各段落内容文本\r document.add_paragraph(\r\u0026#39;Add new paragraph\u0026#39;, style=\u0026#39;ListNumber\u0026#39;\r) #添加新段落\r document.save(\u0026#39;demo.docx\u0026#39;) #保存文档\r   获取特定文本 通过跟学妹沟通，拿到几份判决书看了下，需要的文本就是绿框部分。前后有明显的起始截止标识，直接正则表达式。\n\r\r**正则表达式**\r\r判决如下：(.*?)如不服本判决，\n  .匹配任意除换行符\\n外的字符；\n  *表示匹配前一个字符0次或无限次；\n  +或后跟?表示非贪婪匹配，即尽可能少的匹配，如?重复任意次，但尽可能少重复；\n  .*? 表示匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n如：a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab和ab。\n  \r \r输出特定文本 使用Python-docx模块的add_paragraph()方法将文本从list输出至word中。\n👨‍💻具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #!/usr/bin/env python3\r # -*- coding: utf-8 -*-\r import re\rimport os\rimport importlib,sys # Python 3.4 之后弃用imp\r importlib.reload(sys) # 处理windows与其他os的路径中的\\/\r from pathlib import Path\rfrom docx import Document\rdata_files=[(\u0026#34;\u0026#34;,[\u0026#34;MSVCR100.dll\u0026#34;])]\rfile_path = Path(sys.path[0]) # 调试使用脚本路径\r #file_path = Path(os.getcwd()) # 打包使用程序路径\r document = Document()\rfrom docx.oxml.ns import qn\rdocument.styles[\u0026#39;Normal\u0026#39;].font.name = u\u0026#39;宋体\u0026#39;\rdocument.styles[\u0026#39;Normal\u0026#39;]._element.rPr.rFonts.set(qn(\u0026#39;w:eastAsia\u0026#39;), u\u0026#39;宋体\u0026#39;)\rdef searchFiles():\rword_dir = os.listdir(file_path / \u0026#34;word\u0026#34;)\r# 文件放置在当前目录下的word文件夹中\r i = 0\rfor s in word_dir:\rwordName = word_dir[i]\ri = i + 1\rstr1 = file_path / \u0026#34;word\u0026#34; / wordName\rdocxSearch(str1)\rdocument.save(file_path / \u0026#34;这个就是你需要的文档啦.docx\u0026#34;)\rdef docxSearch(wordName):\rtemplate = \u0026#39;\u0026#39;\rfile = Document(wordName)\rfor para in file.paragraphs:\rtemplate = template + para.text\r# print( para.text )\r slotList = RegularEx(template)\rfor slot in slotList:\rprint (slot)\rdocument.add_paragraph(slot,style=\u0026#39;List Number\u0026#39;)\rdef RegularEx(temp):\rrule = r\u0026#39;判决如下：(.*?)如不服本判决，\u0026#39;\rslotList = re.findall(rule, temp)\rreturn slotList\rif __name__ == \u0026#39;__main__\u0026#39;:\rsearchFiles()\r  ","description":"使用docx+regex从Word获取特定内容","id":1,"section":"posts","tags":["python","word","regexp"],"title":"获取Word特定内容","uri":"https://lynm3k.coding-pages.com/posts/tool-gettextfromword/"},{"content":"\r有时候需要使用正则表达式去验证一些输入信息，故对这些正则表达式进行记录，以便后期使用。\r📧电子邮件 1 2  var email = \u0026#39;zyssmart@live.com\u0026#39;;\rvar emailRegexp = /^[^\\s@]+@[^\\s@.]+\\.[^\\s@.]+$/;\r  🔑密码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  var checkPass = function (password) {\rvar theLength = /^.{8,32}$/; // 长度在8~32个字符之间\r var upper = /[A-Z]/; // 大写字母\r var lower = /[a-z]/; // 小写字母\r var numbers = /[0-9]/; // 数字\r var special = /[!\u0026#34;#$%\u0026amp;\u0026#39;()*+,\\-./:;\u0026lt;=\u0026gt;?@[\\\\\\]^_`{|}~]/; // 特殊字符\r\rif (theLength.test(password) \u0026amp;\u0026amp;\rupper.test(password) \u0026amp;\u0026amp;\rlower.test(password) \u0026amp;\u0026amp;\rnumbers.test(password) \u0026amp;\u0026amp;\rspecial.test(password)\r) {\rreturn true;\r} else {\rreturn false;\r}\r}\r  📅日期 1 2  var date = \u0026#39;2019/01/01\u0026#39;;\rvar dateRegexp = /^([0-9]{2})?[0-9]{2}/(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])$/;\r  📇身份证号 1  var IDRegexp=/\\d{17}[\\d|x]|\\d{15}/;\r  🇨🇳中文 1  var chineseRegexp = /[\\u4e00-\\u9fa5]/gm\r  🔣特殊字符 1 2 3 4  //英文特殊字符\rvar regEn = /[`~!@#$%^\u0026amp;*()_+\u0026lt;\u0026gt;?:\u0026#34;{},\\\\.\\/;\u0026#39;[\\]]/im\r//中文特殊字符\rvar regCn = /[·！#￥（——）：；“”‘、，|《。》？、【】[\\]]/im\r  📱手机号码 1  var phoneNumRegexp = /^[1][3,4,5,7,8][0-9]{9}$/\r  🚘车牌号 1 2 3 4  //新能源 长度为8\rvar xreg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/\r//常规车牌 长度为7\rvar creg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/\r  ","description":"邮件、密码、日期等的合法性校验","id":2,"section":"notes","tags":["JavaScript","regexp"],"title":"JavaScript常用的正则表达式","uri":"https://lynm3k.coding-pages.com/notes/regexp-javascriptregexp/"},{"content":"\rCSV 文件（Comma Separated Values file，即逗号分隔值文件）是一种纯文本文件，它使用特定的结构来排列表格数据。\r📝写在前面 csv特点\n 纯文本，使用某个字符集，比如ASCII、Unicode、EBCDIC或GB2312； 由记录组成（典型的是每行一条记录）； 每条记录被分隔符分隔为字段，常用分隔符：逗号（,）、制表符（\\t）、冒号（:)和分号（;）有时分隔符可以包括可选的空格； 每行末尾是CR回车符和LF换行符（请注意，Linux系统以LF结尾，MacOS系统以CR结尾）。 每条记录都有同样的字段序列。  一般为每行开头不空格，第一行是属性列，数据列之间以间隔符为间隔无空格，行之间无空行。\n如果有空行或者数据集中行末有空格，读取数据时一般会出错，引发[list index out of range]错误。\n🌊使用csv库读写 CSV 文件 reader对象可以通过指定附加参数，处理不同风格的 CSV 文件，其中一些如下所示：\n delimiter指定用于分隔每个字段的字符，默认值为逗号（,）。 quotechar指定用于包围包含分隔符字符的字段的字符，默认值为双引号（\u0026quot;）。 escapechar指定用于转义分隔符的字符，以防引号未使用。默认值为无转义字符。  读取 CSV 文件并直接输出 如果csv文件不是很复杂则可以直接输出文件中每行的数据\n1 2 3 4 5 6 7 8  import csv\rdef read_csv_file(path):\rwith open(path, \u0026#39;rb\u0026#39;) as f: # r表示读取，b表示读取的文件\r reader = csv.reader(f)\rfor row in reader:\rprint row\rf.close()\r  将 CSV 文件并输出为字典 如果想要获取某列的数据，在上面的代码中用数组指定索引即可得到，但是如果较复杂的话采用下面的形式更好，输出字典。这样还有个好处是有时需要反复读取csv文件，但是第一次读取后文件对象已经指向文件末尾了，所以需要将数据存入普通数组，方便后面处理：\n1 2 3 4 5 6 7 8 9 10 11 12  import csv\rdef read_csv_data(path):\rdata_lines = []\rwith open(path, \u0026#39;rb\u0026#39;) as f:\rreader = csv.reader(f)\rfields = reader.next() # 过滤掉表头(如果有的话)\r for row in reader:\ritems = dict(zip(fields, row))\rdata_lines.append(items)\rf.close()\rreturn data_lines\r  写入 CSV 文件 1 2 3 4 5 6 7 8 9 10 11 12  import csv\rdef write_csv_file(path)\rwith open(path, \u0026#39;wb\u0026#39;) as f: # w表示写入，b表示写入文件\r writer = csv.writer(f)\rwriter.writerow([\u0026#39;name\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;age\u0026#39;]) # writerow是写入一行数据\r data = [\r( \u0026#39;ych \u0026#39;,\u0026#39;china\u0026#39;,\u0026#39;25\u0026#39;),\r( \u0026#39;Lily\u0026#39;, \u0026#39;USA\u0026#39;, \u0026#39;24\u0026#39;)]\rwriter.writerows(data) # writerows是写入多行数据\r f.close()\r  🌊输出CSV文件某列的匹配/不匹配的记录 主要用于从csv文件中抽取出匹配特定列的特定字段集合的记录，比如现有这么一个csv文件（表格化后）\n   Name Age sex     Bob 27 male   Alice 23 female   Lancelot 23 unknown   \u0026hellip; \u0026hellip; \u0026hellip;    需要输出其中age为23的记录到新的csv文件，则我们可以先把23这么个关键词用一个列表收集起来，然后通过下列代码从csv文件中找出所有符合条件的记录并输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import sys\rimport csv\r# try to fix \u0026#39;_csv.Error: field larger than field limit (131072)\u0026#39;\r csv.field_size_limit(sys.maxint)\r# write to common csv file with delimiter \u0026#39;,\u0026#39;\r # output the rows with matched id in id_list to a new csv file\r def csv_match(id_list,key,input_file,output_file):\rwith open(input_file, \u0026#39;rb\u0026#39;) as f:\rreader = csv.DictReader(f)\rrows = [row for row in reader if row[key] in set(id_list)]\rheader = rows[0].keys()\rwith open(output_file, \u0026#39;w\u0026#39;) as f:\rf.write(\u0026#39;,\u0026#39;.join(header))\rf.write(\u0026#39;\\n\u0026#39;)\rfor data in rows:\rf.write(\u0026#34;,\u0026#34;.join(data[h] for h in header))\rf.write(\u0026#39;\\n\u0026#39;)\r  调用的时候：\n1 2  lst=[\u0026#39;23\u0026#39;]\rcsv_match(lst,\u0026#39;age\u0026#39;,\u0026#39;in.csv\u0026#39;,\u0026#39;out.csv\u0026#39;)\r  key为需要匹配的列名，另外我们也可以提取不符合该条件的记录，‘取个反’就行了\n1 2 3 4 5 6 7 8 9 10 11 12 13  # output the rows with not matched id in id_list to a new csv file\r def csv_not_match(id_list, key, input_file, output_file):\rwith open(input_file, \u0026#39;rb\u0026#39;) as f:\rreader = csv.DictReader(f)\rrows = [row for row in reader if not row[key] in set(id_list)]\rheader = rows[0].keys()\rwith open(output_file, \u0026#39;w\u0026#39;) as f:\rf.write(\u0026#39;,\u0026#39;.join(header))\rf.write(\u0026#39;\\n\u0026#39;)\rfor data in rows:\rf.write(\u0026#34;,\u0026#34;.join(data[h] for h in header))\rf.write(\u0026#39;\\n\u0026#39;)\r  对于需要判断csv文件中多个列的值的情况，只需修改对应的判别条件和传入参数情况即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # output the rows with matched key1 or key2 in refer_list to a new csv file\r # @params\r # refer_list: the list referred to\r # key,key2: column name of csv file to check the value in the refer_list or not\r def csv_match2(refer_list, key1, key2, input_file, output_file):\rwith open(input_file, \u0026#39;rb\u0026#39;) as f:\rreader = csv.DictReader(f)\rrows = [row for row in reader if (row[key1] in set(refer_list)) or (row[key2] in set(refer_list))]\rheader = rows[0].keys()\rwith open(output_file, \u0026#39;w\u0026#39;) as f:\rf.write(\u0026#39;,\u0026#39;.join(header))\rf.write(\u0026#39;\\n\u0026#39;)\rfor data in rows:\rf.write(\u0026#34;,\u0026#34;.join(data[h] for h in header))\rf.write(\u0026#39;\\n\u0026#39;)\r  🌊调整csv文件的列的顺序 有时候我们输出的或者拿到的csv文件的列的顺序不够‘人性化’，为了让我们看起来更加直观，更舒服一点，我们可以按照我们的需要调整列的顺序\n1 2 3 4 5 6 7 8 9  import csv\r# reorder the column of the csv file to what you want\r def csv_reorder(in_file, out_file,lst_order):\rwith open(in_file, \u0026#39;rb\u0026#39;) as infile, open(out_file, \u0026#39;wb\u0026#39;) as outfile:\rfieldnames=lst_order\rwriter = csv.DictWriter(outfile, fieldnames=fieldnames)\rwriter.writeheader()\rfor row in csv.DictReader(infile):\rwriter.writerow(row)\r  其中lst_order为我们需要的列名顺序，用list存储，举个例子\nseason_id,league_name,league_size\r2003,scottish-premiership,12\r2016,1-hnl,10\r2004,alka-superligaen,12\r2006,allsvenskan,14\r1992,premier-league,22\r...\r现在我们想调整他的顺序，按照league_name,season_id,league_size的顺序重新组合一下\n则调用\n1 2  lst_order = [\u0026#39;league_name\u0026#39;,\u0026#39;season_id\u0026#39;,\u0026#39;league_size\u0026#39;]\rcsv_reorder(\u0026#39;leagues_size.csv\u0026#39;, \u0026#39;leagues_size_new.csv\u0026#39;, lst_order)\r  得到结果\nleague_name,season_id,league_size\rscottish-premiership,2003,12\r1-hnl,2016,10\ralka-superligaen,2004,12\rallsvenskan,2006,14\rpremier-league,1992,22\r...\r🌊抽取特定列 抽取特定列的所有值并存储于列表 获取某列原始的数据并保存为列表\n1 2 3 4 5 6 7 8 9 10  # get certain column value of csv(for common csv file(\u0026#39;,\u0026#39;))\r def get_origin_column_value(file, column_name):\rwith open(file, \u0026#39;rb\u0026#39;) as f:\rrole_list = []\rreader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;)\rfieldnames = next(reader)\rreader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;)\rfor row in reader:\rrole_list.append(row[column_name])\rreturn role_list\r  对于某些有特殊需要的可以直接修改代码，比如对原始的列的值进行除重和排序后获取，如下\n1 2 3 4 5 6 7 8 9 10 11  # get certain column value of csv(for common csv file(\u0026#39;,\u0026#39;)),and judge if it\u0026#39;s repeated\r def get_column_value2(file, column_name):\rwith open(file, \u0026#39;rb\u0026#39;) as f:\rrole_list = []\rreader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;)\rfieldnames = next(reader)\rreader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;)\rfor row in reader:\rrole_list.append(row[column_name])\rrole_set = set(role_list)\rreturn sorted(list(role_set))\r  根据下标抽取特定列到某个新的csv文件 1 2 3 4 5 6 7 8  import csv\r# extract certain column from csv file according to the column#\r def column_extract(file_in,file_out,index):\rwith open(file_in,\u0026#39;r\u0026#39;) as f_in:\rwith open(file_out,\u0026#39;w\u0026#39;) as f_out:\rfor line in f_in:\rf_out.write(line.split(\u0026#39;,\u0026#39;)[index])\rf_out.write(\u0026#39;\\n\u0026#39;) # comment if a new line already exists\r   🌊除去完全重复的记录 1 2 3 4 5 6 7 8 9 10  # eliminated the completely repeated record in repeated file for further analysis\r def eliminate_repeated_row(in_file,out_file):\rwith open(in_file,\u0026#39;rb\u0026#39;) as in_file,open(out_file,\u0026#39;wb\u0026#39;)as out_file:\rseen=set()\rfor line in in_file:\r# print line\r if line in seen:continue\rseen.add(line)\rout_file.write(line)\r  🌊对csv文件按照某一列排序 1 2 3 4 5 6 7 8 9  # sort the csv file by certain column to put the similar record together for further analysis\r def sort_csv_byColumn(in_file, out_file,column_name):\rwith open(in_file, \u0026#39;rb\u0026#39;) as f:\rreader = csv.reader(f, delimiter=\u0026#39;,\u0026#39;)\rfieldnames = next(reader)\rreader = csv.DictReader(f, fieldnames=fieldnames, delimiter=\u0026#39;,\u0026#39;)\rsorted_list = sorted(reader, key=lambda row: row[column_name], reverse=True)\r# print sorted_list\r csv_converter.nestedlist2csv(sorted_list, out_file)\r  例如我们按照league_name排序(注意这里调用了csv转换器中的方法将列表的字典转换为csv文件)\n1  sort_csv_byColumn(\u0026#39;leagues_size.csv\u0026#39;,\u0026#39;ordered_leagues_size.csv\u0026#39;,\u0026#39;league_name\u0026#39;)\r  得到结果\nseason_id,league_name,league_size\r2008,virsliga,9\r2010,virsliga,9\r2012,a-lyga,9\r2012,a-pojat-sm-sarja,9\r2013,a-pojat-sm-sarja,9\r1953,salzburger-liga,9\r2010,3-lig-grup-1,9\r2013,armenian-first-league,9\r2016,ykkonen,9\r2014,stirling-sports-premiership,9\r2014,hong-kong-premier-league,9\r2015,hong-kong-premier-league,9\r1996,s-league,9\r2015,s-league,9\r2013,united-football-league,9\r2016,i-league,9\r🌊键值互换 csv文件每一条记录其实可以看作是一个字典，有时csv文件里有不同的键对应同一个值的情况，我们想讲记录反转一下，即让值作为键，对应的键作为值\n1 2 3 4 5 6  # return a dict with the same value in original as new key and keys as value\r def dict_same_value(original_dict):\rnew_dict={}\rfor k,v in original_dict.iteritems():\rnew_dict.setdefault(v,[]).append(k)\rreturn new_dict\r  🌊参考资料 CSV_Toolkit\n","description":"python处理csv文件经常用到的方法","id":3,"section":"posts","tags":["python","csv"],"title":"python处理csv文件","uri":"https://lynm3k.coding-pages.com/posts/blog-pythonoperatecsv/"},{"content":"\r\rKnow yourself and be yourself!\r\r 纽约时间比加州时间早三个小时，\nNew York is 3 hours ahead of California,\n但加州时间并没有变慢。\nbut it does not make California slow.\n有人22岁就毕业了，\nSomeone graduated at the age of 22,\n但等了5年才找到好的工作！\nbut waited 5 years before securing a good job!\n有人25岁就当上CEO，\nSomeone became a CEO at 25,\n却在50岁去世。\nand died at 50.\n也有人迟到50岁才当上CEO，\nWhile another became a CEO at 50,\n然后活到90岁。\nand lived to 90 years.\n有人依然单身，\nSomeone is still single,\n同时也有人已婚。\nwhile someone else got married.\n奥巴马55岁就退休，\nObama retires at 55,\n川普70岁才开始当总统。\nbut Trump starts at 70.\n世上每个人本来就有自己的发展时区。\nAbsolutely everyone in this world works based on their Time Zone.\n身边有些人看似走在你前面，\nPeople around you might seem to go ahead of you,\n也有人看似走在你后面。\nsome might seem to be behind you.\n但其实每个人在自己的时区有自己的步程。\nBut everyone is running their own RACE, in their own TIME.\n不用嫉妒或嘲笑他们。\nDon’t envy them or mock them.\n他们都在自己的时区里，你也是！\nThey are in their TIME ZONE, and you are in yours!\n生命就是等待正确的行动时机。\nLife is about waiting for the right moment to act.\n所以，放轻松。\nSo, RELAX.\n你没有落后。\nYou’re not LATE.\n你没有领先。\nYou’re not EARLY.\n在命运为你安排的属于自己的时区里，一切都准时。\nYou are very much ON TIME, and in your TIME ZONE Destiny set up for you.\n \r Expectations 二十而立\n三十不惑\n四十知天命\n五十耳顺\n六十从心所欲\nBlog Timeline  2020.04.01：将博客迁移至Hugo+Zzo theme。 2018.05.10：使用Hexo+NEXT theme搭建个人博客。  ","description":"你曾经也是第一名啊。","id":4,"section":"","tags":null,"title":"About","uri":"https://lynm3k.coding-pages.com/about/"}]